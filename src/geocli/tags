!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUF_ACT_COPY	file.h	/^    BUF_ACT_COPY,$/;"	e	enum:__anon2
BUF_ACT_COPY_EMPTY	file.h	/^    BUF_ACT_COPY_EMPTY = 0,$/;"	e	enum:__anon2
BUF_ACT_COPY_OVERLAP	file.h	/^    BUF_ACT_COPY_OVERLAP,$/;"	e	enum:__anon2
BUF_ACT_FLUSH_ALIGN_THEN_COPY_NEW	file.h	/^    BUF_ACT_FLUSH_ALIGN_THEN_COPY_NEW,$/;"	e	enum:__anon2
BUF_ACT_FLUSH_THEN_COPY_NEW	file.h	/^    BUF_ACT_FLUSH_THEN_COPY_NEW,$/;"	e	enum:__anon2
BUF_ACT_MAX	file.h	/^    BUF_ACT_MAX$/;"	e	enum:__anon2
BUF_STATUS_DONE	file.h	/^    BUF_STATUS_DONE = 0,$/;"	e	enum:__anon3
BUF_STATUS_FAILURE	file.h	/^    BUF_STATUS_FAILURE ,$/;"	e	enum:__anon3
BUF_STATUS_MAX	file.h	/^    BUF_STATUS_MAX$/;"	e	enum:__anon3
BUF_STATUS_WR_IN_PRG	file.h	/^    BUF_STATUS_WR_IN_PRG ,$/;"	e	enum:__anon3
BUF_ST_EMPTY	file.h	/^  BUF_ST_EMPTY = 0,$/;"	e	enum:__anon1
BUF_ST_MAX	file.h	/^  BUF_ST_MAX$/;"	e	enum:__anon1
BUF_ST_READ_AFTER	file.h	/^  BUF_ST_READ_AFTER,$/;"	e	enum:__anon1
BUF_ST_READ_BEFORE	file.h	/^  BUF_ST_READ_BEFORE,$/;"	e	enum:__anon1
BUF_ST_READ_INSIDE	file.h	/^  BUF_ST_READ_INSIDE,$/;"	e	enum:__anon1
BUF_ST_WRITE_AFTER	file.h	/^  BUF_ST_WRITE_AFTER,$/;"	e	enum:__anon1
BUF_ST_WRITE_BEFORE	file.h	/^  BUF_ST_WRITE_BEFORE,$/;"	e	enum:__anon1
BUF_ST_WRITE_INSIDE	file.h	/^  BUF_ST_WRITE_INSIDE,$/;"	e	enum:__anon1
CACHE_TIMEOUT	rozofsmount.c	44;"	d	file:
CONNECTION_THREAD_TIMESPEC	rozofsmount.c	48;"	d	file:
DISPLAY_STRING_CONFIG	geocli_srv.c	111;"	d	file:
DISPLAY_STRING_CONFIG	rozofsmount.c	183;"	d	file:
DISPLAY_UINT32_CONFIG	geocli_srv.c	110;"	d	file:
DISPLAY_UINT32_CONFIG	rozofsmount.c	182;"	d	file:
FILE_CHECK_WORD	file.h	27;"	d
GEOCLI_SRV_H	geocli_srv.h	20;"	d
GEOCLI_ST_IDLE	geocli_srv.h	/^  GEOCLI_ST_IDLE = 0,$/;"	e	enum:__anon4
GEOCLI_ST_INPRG	geocli_srv.h	/^  GEOCLI_ST_INPRG,$/;"	e	enum:__anon4
GEOCLI_ST_MAX	geocli_srv.h	/^  GEOCLI_ST_MAX$/;"	e	enum:__anon4
GEOSYNC_ST_GETDEL	geocli_srv.h	/^  GEOSYNC_ST_GETDEL,$/;"	e	enum:__anon5
GEOSYNC_ST_GETNEXT	geocli_srv.h	/^  GEOSYNC_ST_GETNEXT,$/;"	e	enum:__anon5
GEOSYNC_ST_IDLE	geocli_srv.h	/^  GEOSYNC_ST_IDLE = 0,$/;"	e	enum:__anon5
GEOSYNC_ST_MAX	geocli_srv.h	/^  GEOSYNC_ST_MAX$/;"	e	enum:__anon5
GEOSYNC_ST_SYNC_FILE	geocli_srv.h	/^  GEOSYNC_ST_SYNC_FILE,$/;"	e	enum:__anon5
GEO_DEF_PERIO_MS	geocli_srv.h	123;"	d
GEO_IDX_COUNT	geocli_srv.h	73;"	d
GEO_IDX_ERR	geocli_srv.h	75;"	d
GEO_IDX_SAVE_TIME	geocli_srv.h	77;"	d
GEO_IDX_TIME	geocli_srv.h	76;"	d
GEO_IDX_TMO	geocli_srv.h	74;"	d
Global_timeAfter	rozofs_non_blocking_main.c	/^unsigned long long Global_timeBefore, Global_timeAfter;$/;"	v
Global_timeBefore	rozofs_non_blocking_main.c	/^unsigned long long Global_timeBefore, Global_timeAfter;$/;"	v
Global_timeDay	rozofs_non_blocking_main.c	/^struct timeval Global_timeDay;$/;"	v	typeref:struct:timeval
INODE_HSIZE	rozofsmount.c	41;"	d	file:
MICROLONG	rzcp_file_ctx.c	41;"	d	file:
PATH_HSIZE	rozofsmount.c	42;"	d	file:
ROOT_INODE	rozofsmount.h	28;"	d
ROZOFSMOUNT_H	rozofsmount.h	20;"	d
ROZOFSMOUNT_MAX_TX	rozofsmount.c	46;"	d	file:
ROZOFS_RW_LOAD_BALANCING_H	rozofs_rw_load_balancing.h	20;"	d
ROZOFS_SHAREDMEM_H	rozofs_sharedmem.h	20;"	d
RZCPY_MAX_BUF_LEN	rzcp_file_ctx.h	28;"	d
RZCP_COPY_H	rzcp_copy.h	29;"	d
RZCP_CTX_COUNTER_MAX	rzcp_file_ctx.h	/^  RZCP_CTX_COUNTER_MAX,$/;"	e	enum:__anon6
RZCP_CTX_CTX_MISMATCH	rzcp_file_ctx.h	/^  RZCP_CTX_CTX_MISMATCH,$/;"	e	enum:__anon6
RZCP_CTX_DEBUG_TOPIC	rzcp_file_ctx.c	42;"	d	file:
RZCP_CTX_NO_CTX_ERROR	rzcp_file_ctx.h	/^  RZCP_CTX_NO_CTX_ERROR,$/;"	e	enum:__anon6
RZCP_CTX_STATS	rzcp_file_ctx.h	95;"	d
RZCP_CTX_TIMEOUT	rzcp_file_ctx.h	/^  RZCP_CTX_TIMEOUT=0,$/;"	e	enum:__anon6
RZCP_FILE_H	rzcp_file_ctx.h	20;"	d
RZCP_MAX_CTX	rzcp_file_ctx.h	27;"	d
SHOW_GEO_CLI_PROFILER_PROBE	geocli_srv.c	135;"	d	file:
START_GEO_CLI_PROFILING	geocli_srv.h	79;"	d
STCLBG_HASH_SIZE	rozofs_rw_load_balancing.h	24;"	d
STOP_GEO_CLI_PROFILING	geocli_srv.h	87;"	d
STORCLI_EXEC	rozofsmount.c	52;"	d	file:
STORCLI_KILLER	rozofsmount.c	51;"	d	file:
STORCLI_STARTER	rozofsmount.c	50;"	d	file:
TRAFFIC_SHAPER_COUNTER	rozofs_rw_load_balancing.c	103;"	d	file:
XMALLOC_MAX_SIZE	rozofsmount.c	262;"	d	file:
_FILE_H	file.h	20;"	d
_geo_cli_profiler_t	geocli_srv.h	/^typedef struct _geo_cli_profiler_t {$/;"	s
_geocli_ctx_t	geocli_srv.h	/^typedef struct _geocli_ctx_t$/;"	s
_rozo_buf_rw_status_t	file.h	/^typedef struct _rozo_buf_rw_status_t {$/;"	s
_rozofs_fuse_conf_t	rozofsmount.h	/^typedef struct _rozofs_fuse_conf_t$/;"	s
_rozofs_shared_pool_t	rozofs_sharedmem.h	/^typedef struct _rozofs_shared_pool_t$/;"	s
_rzcp_copy_ctx	rzcp_file_ctx.h	/^typedef struct _rzcp_copy_ctx$/;"	s
_rzcp_file_ctx	rzcp_file_ctx.h	/^typedef struct _rzcp_file_ctx$/;"	s
_xmalloc_stats_t	rozofsmount.c	/^typedef struct _xmalloc_stats_t {$/;"	s	file:
af_inet_exportd_conf	geocli_lbg.c	/^static af_unix_socket_conf_t  af_inet_exportd_conf =$/;"	v	file:
args_p	rozofs_non_blocking_main.c	/^static rozofs_fuse_conf_t *args_p;$/;"	v	file:
attr_timeout	rozofsmount.h	/^    unsigned attr_timeout;$/;"	m	struct:rozofsmnt_conf
attrs	file.h	/^    mattr_t attrs;$/;"	m	struct:file
bsd_file_lock	rozofsmount.h	/^    unsigned bsd_file_lock;  $/;"	m	struct:rozofsmnt_conf
buf_count	rozofs_sharedmem.h	/^   uint32_t buf_count;  \/**< number of buffer              *\/$/;"	m	struct:_rozofs_shared_pool_t
buf_read_pending	file.h	/^    int buf_read_pending;    \/**< number of read requests that are pending *\/$/;"	m	struct:file
buf_read_wait	file.h	/^    int buf_read_wait;$/;"	m	struct:file
buf_size	rozofsmount.h	/^    unsigned buf_size;$/;"	m	struct:rozofsmnt_conf
buf_sz	rozofs_sharedmem.h	/^   uint32_t buf_sz;     \/**< size of a buffer              *\/$/;"	m	struct:_rozofs_shared_pool_t
buf_write_pending	file.h	/^    int buf_write_pending;   \/**< number of write requests that are pending *\/$/;"	m	struct:file
buf_write_wait	file.h	/^    int buf_write_wait;$/;"	m	struct:file
buffer	file.h	/^    char *buffer;$/;"	m	struct:file
buffer	rzcp_file_ctx.h	/^   void *buffer;           \/**< reference of the  buffer allocated thanks malloc *\/$/;"	m	struct:_rzcp_copy_ctx
cache_mode	rozofsmount.h	/^    unsigned cache_mode;  \/**< 0: no option, 1: direct_read, 2: keep_cache *\/$/;"	m	struct:rozofsmnt_conf
ch	rozofsmount.h	/^   void    *ch;           \/**< pointer to the channel context     *\/$/;"	m	struct:_rozofs_fuse_conf_t
chekWord	file.h	/^    int   chekWord;$/;"	m	struct:file
cid	rzcp_file_ctx.h	/^    cid_t cid;                      \/**< cluster id 0 for non regular files             *\/$/;"	m	struct:_rzcp_file_ctx
closing	file.h	/^    int closing;             \/**< assert to 1 when the file has to be closed and there are some disks operation pending *\/$/;"	m	struct:file
conf	rozofsmount.c	/^static rozofsmnt_conf_t conf;$/;"	v	file:
count	rozofsmount.c	/^    uint64_t count;$/;"	m	struct:_xmalloc_stats_t	file:
cur_record	geocli_srv.h	/^   uint32_t cur_record;    \/**< current index in data_record             *\/$/;"	m	struct:_geocli_ctx_t
current_pos	file.h	/^    uint64_t current_pos;\/**< Estimated current position in the file *\/$/;"	m	struct:file
data_p	rozofs_sharedmem.h	/^   void *data_p;        \/**< pointer to the beginning of the shared memory     *\/$/;"	m	struct:_rozofs_shared_pool_t
data_record	geocli_srv.h	/^   char     *data_record;$/;"	m	struct:_geocli_ctx_t
data_record_len	geocli_srv.h	/^   uint32_t data_record_len;$/;"	m	struct:_geocli_ctx_t
dbg_port	rozofsmount.h	/^    unsigned dbg_port;  \/**< lnkdebug base port: rozofsmount=dbg_port, storcli(1)=dbg_port+1, ....  *\/$/;"	m	struct:rozofsmnt_conf
debug_port	rozofsmount.h	/^   uint16_t debug_port;   \/**< port value to be used by rmonitor  *\/$/;"	m	struct:_rozofs_fuse_conf_t
eid	geocli_srv.h	/^   uint16_t  eid;      \/**< export identifier *\/$/;"	m	struct:_geocli_ctx_t
entry_timeout	rozofsmount.h	/^    unsigned entry_timeout;$/;"	m	struct:rozofsmnt_conf
errcode	file.h	/^    int errcode;$/;"	m	struct:_rozo_buf_rw_status_t
errcode	rzcp_file_ctx.h	/^    int      errcode;     $/;"	m	struct:_rzcp_file_ctx
errcode	rzcp_file_ctx.h	/^   int   errcode;          \/**< operation errcode               *\/$/;"	m	struct:_rzcp_copy_ctx
export	file.h	/^    exportclt_t *export;$/;"	m	struct:file
export	rozofsmount.h	/^    char *export;$/;"	m	struct:rozofsmnt_conf
export_lbg_periodic_ticker	geocli_lbg.c	/^static void export_lbg_periodic_ticker(void * param) {$/;"	f	file:
export_lbg_start_timer	geocli_lbg.c	/^static void export_lbg_start_timer(exportclt_t *exportclt) {$/;"	f	file:
export_timeout	rozofsmount.h	/^    unsigned export_timeout;$/;"	m	struct:rozofsmnt_conf
exportclt	rozofsmount.c	/^exportclt_t exportclt; $/;"	v
exportclt	rozofsmount.h	/^   void    *exportclt;           \/**< pointer to the exportd conf     *\/$/;"	m	struct:_rozofs_fuse_conf_t
fdl_debug	geocli_srv.c	/^int fdl_debug = 1;$/;"	v
fid	file.h	/^    fid_t fid;$/;"	m	struct:file
fid	rzcp_file_ctx.h	/^    fid_t fid;                      \/**< file identifier                                *\/$/;"	m	struct:_rzcp_file_ctx
fid_cmp	rozofs_rw_load_balancing.c	/^static inline int fid_cmp(void *key1, void *key2) {$/;"	f	file:
fid_hash	rozofs_rw_load_balancing.c	/^static unsigned int fid_hash(void *key) {$/;"	f	file:
file	file.h	/^typedef struct file {$/;"	s
file2create	file.h	/^    int              file2create;     \/**< assert to one on a write when the attributes indicates a file size of 0    *\/$/;"	m	struct:file
file_close	file.h	/^static inline int file_close(file_t * f) {$/;"	f
file_idx	geocli_srv.h	/^   uint64_t file_idx;$/;"	m	struct:_geocli_ctx_t
file_t	file.h	/^} file_t;$/;"	t	typeref:struct:file
first_record	geocli_srv.h	/^   uint32_t first_record;  \/**< index of the first record in data_record *\/$/;"	m	struct:_geocli_ctx_t
free	rzcp_file_ctx.h	/^   uint32_t            free;      \/**< Is the context free or allocated TRUE\/FALSE      *\/$/;"	m	struct:_rzcp_copy_ctx
fs_mode	rozofsmount.h	/^    unsigned fs_mode; \/**< rozofs mode: 0-> file system\/ 1-> block mode *\/$/;"	m	struct:rozofsmnt_conf
fuse_req	file.h	/^    void           * fuse_req;       \/**< Pointer to the saved fuse request when waiting for a blocking lock *\/$/;"	m	struct:file
fuseloop	rozofsmount.c	/^int fuseloop(\/*struct fuse_args *args,*\/ int fg) {$/;"	f
geo_cli_geo_file_sync_processing	geocli_file_copy.c	/^void geo_cli_geo_file_sync_processing(geocli_ctx_t *p)$/;"	f
geo_cli_geo_file_sync_read_end_cbk	geocli_file_copy.c	/^void geo_cli_geo_file_sync_read_end_cbk(void *param,int status)$/;"	f
geo_cli_geo_file_sync_write_end_cbk	geocli_file_copy.c	/^void geo_cli_geo_file_sync_write_end_cbk(void *param,int status)$/;"	f
geo_cli_geo_sync_delete_req_cbk	geocli_srv.c	/^void geo_cli_geo_sync_delete_req_cbk(void *this,void *param) $/;"	f
geo_cli_geo_sync_delete_req_processing	geocli_srv.c	/^void geo_cli_geo_sync_delete_req_processing(geocli_ctx_t *p)$/;"	f
geo_cli_geo_sync_get_next_req_cbk	geocli_srv.c	/^void geo_cli_geo_sync_get_next_req_cbk(void *this,void *param) $/;"	f
geo_cli_geo_sync_get_next_req_processing	geocli_srv.c	/^void geo_cli_geo_sync_get_next_req_processing(geocli_ctx_t *p)$/;"	f
geo_cli_geo_sync_req_processing	geocli_srv.c	/^void geo_cli_geo_sync_req_processing(geocli_ctx_t *p)$/;"	f
geo_cli_periodic_ticker	geocli_srv.c	/^static void geo_cli_periodic_ticker(void * param) {$/;"	f	file:
geo_cli_profiler_t	geocli_srv.h	/^} geo_cli_profiler_t;$/;"	t	typeref:struct:_geo_cli_profiler_t
geo_cli_start_timer	geocli_srv.c	/^int geo_cli_start_timer(int period)$/;"	f
geo_cli_state_idle_processing	geocli_srv.c	/^void geo_cli_state_idle_processing(geocli_ctx_t *p)$/;"	f
geo_cli_sync_req_cbk	geocli_srv.c	/^void geo_cli_sync_req_cbk(void *this,void *param) $/;"	f
geo_read_req	geocli_read.c	/^int geo_read_req(rzcp_copy_ctx_t * cpy_p) $/;"	f
geo_replica_log_enable	geocli_srv.c	/^int geo_replica_log_enable = 0;$/;"	v
geo_srv_timestamp	rzcp_file_ctx.c	/^uint32_t geo_srv_timestamp=1;$/;"	v
geo_sync_delete_req	geocli_srv.h	/^  uint64_t geo_sync_delete_req[5];$/;"	m	struct:_geo_cli_profiler_t
geo_sync_get_next_req	geocli_srv.h	/^  uint64_t geo_sync_get_next_req[5];$/;"	m	struct:_geo_cli_profiler_t
geo_sync_req	geocli_srv.h	/^  uint64_t geo_sync_req[5];$/;"	m	struct:_geo_cli_profiler_t
geocli_alloc_ctx	geocli_srv.c	/^int geocli_alloc_ctx(uint16_t eid,uint16_t site)$/;"	f
geocli_ctx_p	geocli_srv.c	/^geocli_ctx_t *geocli_ctx_p= NULL;$/;"	v
geocli_ctx_state_e	geocli_srv.h	/^} geocli_ctx_state_e;$/;"	t	typeref:enum:__anon4
geocli_ctx_t	geocli_srv.h	/^} geocli_ctx_t;   $/;"	t	typeref:struct:_geocli_ctx_t
geocli_display_one_file_info	geocli_srv.c	/^char *geocli_display_one_file_info(char *p,geo_fid_entry_t *info_p)$/;"	f
geocli_init	geocli_srv.c	/^int geocli_init(int period,uint16_t eid,uint16_t site_id)$/;"	f
geocli_period	geocli_srv.c	/^int geocli_period;  $/;"	v
geocli_sync_state_e	geocli_srv.h	/^} geocli_sync_state_e;$/;"	t	typeref:enum:__anon5
georep_lbg_initialize	geocli_lbg.c	/^int georep_lbg_initialize(exportclt_t *exportclt ,unsigned long prog,$/;"	f
get_service_tcp_port	geocli_lbg.c	/^static int get_service_tcp_port(char *host ,unsigned long prog, unsigned long vers) {$/;"	f	file:
hash_xor8	rozofsmount.c	40;"	d	file:
hash_xor8	rozofsmount.h	27;"	d
host	rozofsmount.h	/^    char *host;$/;"	m	struct:rozofsmnt_conf
ie	file.h	/^    void           * ie;               \/**< Pointer ot the ientry in the cache *\/$/;"	m	struct:file
index	rzcp_file_ctx.h	/^   uint32_t            index;     \/**< Index of the context                             *\/$/;"	m	struct:_rzcp_copy_ctx
initial_len	rzcp_file_ctx.h	/^    uint64_t initial_len;     \/**< initial length         *\/$/;"	m	struct:_rzcp_file_ctx
instance	rozofsmount.h	/^    unsigned instance;  \/**< rozofsmount instance: needed when more than 1 rozofsmount run the same server and exports the same filesystem *\/$/;"	m	struct:rozofsmnt_conf
instance	rozofsmount.h	/^   uint16_t instance;     \/**< rozofsmount instance: needed when more than 1 rozofsmount run the same server and exports the same filesystem *\/$/;"	m	struct:_rozofs_fuse_conf_t
integrity	rzcp_file_ctx.h	/^   uint32_t            integrity; \/**< the value of this field is incremented at  each ctx allocation *\/$/;"	m	struct:_rzcp_copy_ctx
key	rozofs_sharedmem.h	/^   key_t key;           \/**< key of the shared memory pool *\/$/;"	m	struct:_rozofs_shared_pool_t
last	geocli_srv.h	/^   uint32_t last;$/;"	m	struct:_geocli_ctx_t
layout	rzcp_file_ctx.h	/^    int   layout;                   \/**< layout of the file                             *\/$/;"	m	struct:_rzcp_file_ctx
len2read	rzcp_file_ctx.h	/^   int len2read;                 \/**< effective length to read *\/$/;"	m	struct:_rzcp_copy_ctx
len_cur	rzcp_file_ctx.h	/^    uint64_t len_cur;         \/**< current length         *\/$/;"	m	struct:_rzcp_file_ctx
link	rzcp_file_ctx.h	/^   ruc_obj_desc_t    link;        \/**< To be able to chain the context on any list      *\/$/;"	m	struct:_rzcp_copy_ctx
local_ref	geocli_srv.h	/^   uint32_t local_ref;$/;"	m	struct:_geocli_ctx_t
lock_delay	file.h	/^    int              lock_delay;$/;"	m	struct:file
lock_owner_ref	file.h	/^    uint64_t         lock_owner_ref; \/**< Owner of the lock when a lock has been set. Used to release any$/;"	m	struct:file
lock_size	file.h	/^    int              lock_size;      $/;"	m	struct:file
lock_sleep	file.h	/^    int              lock_sleep;   $/;"	m	struct:file
lock_start	file.h	/^    uint64_t         lock_start;     $/;"	m	struct:file
lock_stop	file.h	/^    uint64_t         lock_stop;$/;"	m	struct:file
lock_type	file.h	/^    int              lock_type;      \/**< Type of requested lock : EP_LOCK_READ or EP_LOCK_WRITE *\/   $/;"	m	struct:file
main	rozofsmount.c	/^int main(int argc, char *argv[]) {$/;"	f
max_retry	rozofsmount.h	/^    unsigned max_retry;$/;"	m	struct:rozofsmnt_conf
max_transactions	rozofsmount.h	/^   int      max_transactions; \/**< max number of simultaneous transactions *\/$/;"	m	struct:_rozofs_fuse_conf_t
max_write_pending	rozofsmount.h	/^    unsigned max_write_pending ; \/**< Maximum number pending write *\/$/;"	m	struct:rozofsmnt_conf
min_read_size	rozofsmount.h	/^    unsigned min_read_size;$/;"	m	struct:rozofsmnt_conf
mode	file.h	/^    mode_t mode;$/;"	m	struct:file
mountpoint	rozofsmount.c	/^static char *mountpoint = NULL;$/;"	v	file:
my_list	geocli_lbg.c	/^static north_remote_ip_list_t my_list[32];  \/**< list of the connection for the exportd *\/$/;"	v	file:
nb_cores	rozofsmount.h	/^    unsigned nb_cores;$/;"	m	struct:rozofsmnt_conf
nb_cores	rozofsmount.h	/^   uint16_t nb_cores;     \/**< Number of core files *\/$/;"	m	struct:_rozofs_fuse_conf_t
nb_records	geocli_srv.h	/^   uint32_t nb_records;    \/**< nb records in data record                *\/$/;"	m	struct:_geocli_ctx_t
nbstorcli	rozofsmount.h	/^    unsigned nbstorcli;    $/;"	m	struct:rozofsmnt_conf
noXattr	rozofsmount.h	/^    unsigned noXattr;$/;"	m	struct:rozofsmnt_conf
off_cur	rzcp_file_ctx.h	/^    uint64_t off_cur;         \/**< current read offset    *\/$/;"	m	struct:_rzcp_file_ctx
off_start	rzcp_file_ctx.h	/^    uint64_t off_start;       \/**< starting offset        *\/$/;"	m	struct:_rzcp_file_ctx
off_wr_end	file.h	/^    uint64_t         off_wr_end;      \/**< geo replication :write offset end  *\/$/;"	m	struct:file
off_wr_start	file.h	/^    uint64_t         off_wr_start;    \/**< geo replication :write offset start  *\/$/;"	m	struct:file
opaque	rzcp_file_ctx.h	/^   void *opaque;$/;"	m	struct:_rzcp_copy_ctx
passwd	rozofsmount.h	/^    char *passwd;$/;"	m	struct:rozofsmnt_conf
pending_lock	file.h	/^    ruc_obj_desc_t   pending_lock;   \/**< To queue the context waiting for a blocking lock *\/$/;"	m	struct:file
pending_rd_list	file.h	/^    ruc_obj_desc_t pending_rd_list;  \/**< used to queue the FUSE contextr for which a read is requested  *\/$/;"	m	struct:file
pending_wr_list	file.h	/^    ruc_obj_desc_t pending_wr_list;  \/**< used to queue the FUSE context waiting for flush completed  *\/$/;"	m	struct:file
pool_p	rozofs_sharedmem.h	/^   void *pool_p;        \/**< reference of the pool         *\/$/;"	m	struct:_rozofs_shared_pool_t
posix_file_lock	rozofsmount.h	/^    unsigned posix_file_lock;    $/;"	m	struct:rozofsmnt_conf
profiler	geocli_srv.h	/^   geo_cli_profiler_t profiler;$/;"	m	struct:_geocli_ctx_t
quota	rozofsmount.h	/^    unsigned quota; \/* ignored *\/$/;"	m	struct:rozofsmnt_conf
read_consistency	file.h	/^    uint64_t         read_consistency; \/**< To check whether the buffer can be read safely *\/$/;"	m	struct:file
read_ctx	rzcp_file_ctx.h	/^   rzcp_file_ctx_t read_ctx;$/;"	m	struct:_rzcp_copy_ctx
read_from	file.h	/^    uint64_t read_from; \/**< absolute position of the last available byte to read *\/$/;"	m	struct:file
read_pos	file.h	/^    uint64_t read_pos;  \/**< absolute position of the first available byte to read*\/$/;"	m	struct:file
read_stats	rozofs_sharedmem.h	/^   uint64_t read_stats; \/**< read statistics: incremented each time it is allocated     *\/$/;"	m	struct:_rozofs_shared_pool_t
received_len	rzcp_file_ctx.h	/^   int received_len;             \/**< received length          *\/$/;"	m	struct:_rzcp_copy_ctx
remote_ref	geocli_srv.h	/^   uint32_t remote_ref;$/;"	m	struct:_geocli_ctx_t
retry_cur	rzcp_file_ctx.h	/^    int      retry_cur;  $/;"	m	struct:_rzcp_file_ctx
rotate	rozofsmount.h	/^    unsigned rotate;$/;"	m	struct:rozofsmnt_conf
rotation_counter	file.h	/^    int rotation_counter;\/**< Rotation counter on file distribution. Incremented on each rotation *\/$/;"	m	struct:file
rotation_counter	rzcp_file_ctx.h	/^    int rotation_counter; \/**< Rotation counter on file distribution. Incremented on each rotation *\/$/;"	m	struct:_rzcp_file_ctx
rotation_idx	file.h	/^    int rotation_idx;    \/**< Rotation index within the rozo forward distribution *\/ $/;"	m	struct:file
rotation_idx	rzcp_file_ctx.h	/^    int rotation_idx;     \/**< Rotation index within the rozo forward distribution *\/ $/;"	m	struct:_rzcp_file_ctx
rozo_buf_rw_status_t	file.h	/^} rozo_buf_rw_status_t;$/;"	t	typeref:struct:_rozo_buf_rw_status_t
rozofs_align_off_and_len	geocli_read.c	/^static inline void rozofs_align_off_and_len(uint64_t off, int len, uint64_t * off_aligned, int * len_aligned) {$/;"	f	file:
rozofs_alloc_shared_storcli_buf	rozofs_sharedmem.h	/^static inline void  *rozofs_alloc_shared_storcli_buf(int storcli_idx)$/;"	f
rozofs_buf_read_write_action_e	file.h	/^ } rozofs_buf_read_write_action_e;$/;"	t	typeref:enum:__anon2
rozofs_buf_read_write_state_e	file.h	/^} rozofs_buf_read_write_state_e;$/;"	t	typeref:enum:__anon1
rozofs_buf_read_write_status_e	file.h	/^ } rozofs_buf_read_write_status_e;$/;"	t	typeref:enum:__anon3
rozofs_client_hash	rozofsmount.c	/^uint64_t   rozofs_client_hash=0;$/;"	v
rozofs_client_hash_compute	rozofsmount.c	/^static inline uint64_t rozofs_client_hash_compute(char * hostname, int instance) {$/;"	f	file:
rozofs_create_shared_memory	rozofs_sharedmem.c	/^int rozofs_create_shared_memory(int key_instance,int storcli_idx,uint32_t buf_nb, uint32_t buf_sz)$/;"	f
rozofs_exit	rozofsmount.c	/^void rozofs_exit() {$/;"	f
rozofs_export_send_common	rozofs_tx_client_export.c	/^int rozofs_export_send_common(exportclt_t * clt,uint32_t timeout_sec,uint32_t prog,uint32_t vers,$/;"	f
rozofs_file_working_var_init	file.h	/^static inline void rozofs_file_working_var_init(file_t *file, void * ientry)$/;"	f
rozofs_fuse_conf_t	rozofsmount.h	/^} rozofs_fuse_conf_t;$/;"	t	typeref:struct:_rozofs_fuse_conf_t
rozofs_geo_write_update	file.h	/^static inline void rozofs_geo_write_update(file_t *file,size_t size, off_t off)$/;"	f
rozofs_get_shared_storcli_payload_idx	rozofs_sharedmem.h	/^static inline int rozofs_get_shared_storcli_payload_idx(void *ruc_buf,int storcli_idx,uint32_t *length_p)$/;"	f
rozofs_get_site_number	rozofsmount.h	/^static inline int rozofs_get_site_number()$/;"	f
rozofs_init_shared_memory	rozofs_sharedmem.c	/^void rozofs_init_shared_memory()$/;"	f
rozofs_is_file_closing	file.h	/^ static inline int rozofs_is_file_closing (file_t * f) $/;"	f
rozofs_kill_one_storcli	rozofsmount.c	/^void rozofs_kill_one_storcli(int instance) {$/;"	f
rozofs_kill_storcli	rozofsmount.c	/^void rozofs_kill_storcli() {$/;"	f
rozofs_rotation_read_modulo	rozofsmount.c	/^int rozofs_rotation_read_modulo = 0;$/;"	v
rozofs_shared_mem_display	rozofs_sharedmem.c	/^void rozofs_shared_mem_display(char * argv[], uint32_t tcpRef, void *bufRef)$/;"	f
rozofs_shared_pool_t	rozofs_sharedmem.h	/^} rozofs_shared_pool_t;$/;"	t	typeref:struct:_rozofs_shared_pool_t
rozofs_site_number	rozofsmount.c	/^int rozofs_site_number;  \/**< site number for geo-replication *\/$/;"	v
rozofs_start_one_storcli	rozofsmount.c	/^void rozofs_start_one_storcli(int instance) {$/;"	f
rozofs_start_storcli	rozofsmount.c	/^void rozofs_start_storcli() {$/;"	f
rozofs_stat_start	rozofs_non_blocking_main.c	/^int rozofs_stat_start(void *args) {$/;"	f
rozofs_storcli_send_common	rozofs_tx_client_export.c	/^int rozofs_storcli_send_common(exportclt_t * clt,uint32_t timeout_sec,uint32_t prog,uint32_t vers,$/;"	f
rozofs_storcli_shared_mem	rozofs_sharedmem.c	/^rozofs_shared_pool_t rozofs_storcli_shared_mem[STORCLI_PER_FSMOUNT];$/;"	v
rozofsmnt_conf	rozofsmount.h	/^typedef struct rozofsmnt_conf {$/;"	s
rozofsmnt_conf_t	rozofsmount.h	/^} rozofsmnt_conf_t;$/;"	t	typeref:struct:rozofsmnt_conf
rozofsmount_profile_svc	rozofsmount.c	/^static SVCXPRT *rozofsmount_profile_svc = 0;$/;"	v	file:
ruc_init	rozofs_non_blocking_main.c	/^uint32_t ruc_init(uint32_t test, uint16_t debug_port) {$/;"	f
rzcp_align_off_and_len	rzcp_copy.h	/^static inline void rzcp_align_off_and_len(uint64_t off, uint64_t len, uint64_t * off_aligned, uint64_t * len_aligned) {$/;"	f
rzcp_alloc	rzcp_file_ctx.c	/^rzcp_copy_ctx_t *rzcp_alloc() {$/;"	f
rzcp_caller_cbk	rzcp_file_ctx.h	/^   rzcp_cpy_pf_t rzcp_caller_cbk;  \/**< callback for end of copy service *\/     $/;"	m	struct:_rzcp_copy_ctx
rzcp_context_activeListHead	rzcp_file_ctx.c	/^rzcp_copy_ctx_t rzcp_context_activeListHead; \/**< list of the active context     *\/$/;"	v
rzcp_context_allocated	rzcp_file_ctx.c	/^uint32_t rzcp_context_allocated; \/**< current number of allocated context        *\/$/;"	v
rzcp_context_count	rzcp_file_ctx.c	/^uint32_t rzcp_context_count; \/**< Max number of contexts    *\/$/;"	v
rzcp_context_freeListHead	rzcp_file_ctx.c	/^rzcp_copy_ctx_t *rzcp_context_freeListHead; \/**< head of list of the free context  *\/$/;"	v
rzcp_context_pfirst	rzcp_file_ctx.c	/^rzcp_copy_ctx_t *rzcp_context_pfirst; \/**< pointer to the first context of the pool *\/$/;"	v
rzcp_copy_cbk	rzcp_file_ctx.h	/^   rzcp_cpy_pf_t rzcp_copy_cbk;  \/**< callback for end of read or write transaction*\/$/;"	m	struct:_rzcp_copy_ctx
rzcp_copy_ctx_t	rzcp_file_ctx.h	/^} rzcp_copy_ctx_t;$/;"	t	typeref:struct:_rzcp_copy_ctx
rzcp_copy_init	rzcp_copy.c	/^rzcp_copy_ctx_t *rzcp_copy_init(fid_t fid_s,cid_t cid_s,sid_t *sids_s,uint8_t layout_s,uint64_t off_start,uint64_t len,$/;"	f
rzcp_cpy_pf_t	rzcp_file_ctx.h	/^typedef void (*rzcp_cpy_pf_t)(void*,int);$/;"	t
rzcp_createIndex	rzcp_file_ctx.c	/^uint32_t rzcp_createIndex(uint32_t context_id) {$/;"	f
rzcp_ctxInit	rzcp_file_ctx.c	/^void rzcp_ctxInit(rzcp_copy_ctx_t *p, uint8_t creation) {$/;"	f
rzcp_ctx_stats_e	rzcp_file_ctx.h	/^} rzcp_ctx_stats_e;$/;"	t	typeref:enum:__anon6
rzcp_debug	rzcp_file_ctx.c	/^void rzcp_debug(char * argv[], uint32_t tcpRef, void *bufRef) {$/;"	f
rzcp_debug_init	rzcp_file_ctx.c	/^void rzcp_debug_init() {$/;"	f
rzcp_debug_show	rzcp_file_ctx.c	/^void rzcp_debug_show(uint32_t tcpRef, void *bufRef) {$/;"	f
rzcp_file_ctx_t	rzcp_file_ctx.h	/^} rzcp_file_ctx_t;  $/;"	t	typeref:struct:_rzcp_file_ctx
rzcp_free_from_idx	rzcp_file_ctx.c	/^uint32_t rzcp_free_from_idx(uint32_t context_id) {$/;"	f
rzcp_free_from_ptr	rzcp_file_ctx.c	/^uint32_t rzcp_free_from_ptr(rzcp_copy_ctx_t *p) {$/;"	f
rzcp_getObjCtx_p	rzcp_file_ctx.c	/^rzcp_copy_ctx_t *rzcp_getObjCtx_p(uint32_t context_id) {$/;"	f
rzcp_getObjCtx_ref	rzcp_file_ctx.c	/^uint32_t rzcp_getObjCtx_ref(rzcp_copy_ctx_t *p) {$/;"	f
rzcp_get_free_ctx_number	rzcp_file_ctx.c	/^int rzcp_get_free_ctx_number(void){$/;"	f
rzcp_global_context_id	rzcp_file_ctx.c	/^uint32_t rzcp_global_context_id = 0;$/;"	v
rzcp_module_init	rzcp_file_ctx.c	/^int rzcp_module_init(uint32_t context_count) $/;"	f
rzcp_read_cbk	geocli_read.c	/^void rzcp_read_cbk(void *this,void *param) $/;"	f
rzcp_read_cbk	rzcp_read.c	/^void rzcp_read_cbk(void *this,void *param) $/;"	f
rzcp_read_req	rzcp_read.c	/^int rzcp_read_req(rzcp_copy_ctx_t * cpy_p) $/;"	f
rzcp_stats	rzcp_file_ctx.c	/^uint64_t rzcp_stats[RZCP_CTX_COUNTER_MAX];$/;"	v
rzcp_write_cbk	rzcp_write.c	/^void rzcp_write_cbk(void *this,void *param) $/;"	f
rzcp_write_req	rzcp_write.c	/^int rzcp_write_req(rzcp_copy_ctx_t * cpy_p) $/;"	f
se	rozofsmount.h	/^   void     *se;          \/**< pointer to the session context     *\/$/;"	m	struct:_rozofs_fuse_conf_t
semForEver	rozofsmount.c	/^sem_t *semForEver; \/**< semaphore used for stopping rozofsmount: typically on umount *\/$/;"	v
shaper	rozofsmount.h	/^    unsigned shaper;$/;"	m	struct:rozofsmnt_conf
shared_buf_idx	rzcp_file_ctx.h	/^   int   shared_buf_idx;   \/**< index of the shared buffer      *\/$/;"	m	struct:_rzcp_copy_ctx
shared_buf_ref	rzcp_file_ctx.h	/^   void *shared_buf_ref;   \/**< pointer to the shared buffer    *\/$/;"	m	struct:_rzcp_copy_ctx
show_geo_current_files	geocli_srv.c	/^void show_geo_current_files(char * argv[], uint32_t tcpRef, void *bufRef) {$/;"	f
show_geo_profiler	geocli_srv.c	/^void show_geo_profiler(char * argv[], uint32_t tcpRef, void *bufRef) {$/;"	f
show_geo_profiler_display	geocli_srv.c	/^char * show_geo_profiler_display(char * pChar) {$/;"	f
show_geo_profiler_help	geocli_srv.c	/^static char * show_geo_profiler_help(char * pChar) {$/;"	f	file:
show_rotate_modulo	rozofsmount.c	/^void show_rotate_modulo(char * argv[], uint32_t tcpRef, void *bufRef) {$/;"	f
show_rotate_modulo_help	rozofsmount.c	/^static char * show_rotate_modulo_help(char * pChar) {$/;"	f	file:
show_start_config	rozofsmount.c	/^void show_start_config(char * argv[], uint32_t tcpRef, void *bufRef) {$/;"	f
show_stclbg	rozofs_rw_load_balancing.c	/^void show_stclbg(char * argv[], uint32_t tcpRef, void *bufRef) $/;"	f
show_stclbg_help	rozofs_rw_load_balancing.c	/^static char * show_stclbg_help(char * pChar) {$/;"	f	file:
show_synchro_ctx	geocli_srv.c	/^void show_synchro_ctx(char * argv[], uint32_t tcpRef, void *bufRef) {$/;"	f
show_xmalloc	rozofsmount.c	/^void show_xmalloc(char * argv[], uint32_t tcpRef, void *bufRef) {$/;"	f
sids	rzcp_file_ctx.h	/^    sid_t sids[ROZOFS_SAFE_MAX];    \/**< sid of storage nodes target (regular file only)*\/    $/;"	m	struct:_rzcp_file_ctx
site	rozofsmount.h	/^    unsigned site;$/;"	m	struct:rozofsmnt_conf
site	rozofsmount.h	/^   unsigned site;$/;"	m	struct:_rozofs_fuse_conf_t
site_id	geocli_srv.h	/^   uint16_t  site_id;   \/**< local site identifier *\/$/;"	m	struct:_geocli_ctx_t
size	rozofsmount.c	/^    int size;$/;"	m	struct:_xmalloc_stats_t	file:
state	geocli_srv.h	/^   geocli_ctx_state_e state;$/;"	m	struct:_geocli_ctx_t
state_sync	geocli_srv.h	/^   geocli_sync_state_e state_sync;$/;"	m	struct:_geocli_ctx_t
status	file.h	/^    int status;$/;"	m	struct:_rozo_buf_rw_status_t
stclbg_get_storcli_number	rozofs_rw_load_balancing.c	/^int stclbg_get_storcli_number (void) {$/;"	f
stclbg_hash_lookup_hit_count	rozofs_rw_load_balancing.c	/^uint64_t stclbg_hash_lookup_hit_count;$/;"	v
stclbg_hash_lookup_insert_count	rozofs_rw_load_balancing.c	/^uint64_t stclbg_hash_lookup_insert_count;$/;"	v
stclbg_hash_lookup_miss_count	rozofs_rw_load_balancing.c	/^uint64_t stclbg_hash_lookup_miss_count;$/;"	v
stclbg_hash_table	rozofs_rw_load_balancing.c	/^ruc_obj_desc_t stclbg_hash_table[STCLBG_HASH_SIZE];$/;"	v
stclbg_hash_table_insert_ctx	rozofs_rw_load_balancing.c	/^void stclbg_hash_table_insert_ctx(rozofs_tx_rw_lbg_t *p, fid_t fid, int storcli_idx)$/;"	f
stclbg_hash_table_search_ctx	rozofs_rw_load_balancing.c	/^rozofs_tx_rw_lbg_t *stclbg_hash_table_search_ctx(fid_t fid, int *storcli_idx)$/;"	f
stclbg_init	rozofs_rw_load_balancing.c	/^void stclbg_init()$/;"	f
stclbg_init_done	rozofs_rw_load_balancing.c	/^int stclbg_init_done = 0;$/;"	v
stclbg_next_idx	rozofs_rw_load_balancing.c	/^int stclbg_next_idx = 0; \/**< index of the next storcli to use *\/$/;"	v
stclbg_set_storcli_number	rozofs_rw_load_balancing.c	/^int stclbg_set_storcli_number (int nb) {$/;"	f
stclbg_storcli_count	rozofs_rw_load_balancing.c	/^int stclbg_storcli_count = 1;$/;"	v
stclbg_storcli_idx_from_fid	rozofs_rw_load_balancing.c	/^int stclbg_storcli_idx_from_fid(fid_t fid)$/;"	f
stclbg_storcli_stats	rozofs_rw_load_balancing.c	/^uint64_t stclbg_storcli_stats[STORCLI_PER_FSMOUNT];$/;"	v
stclbg_update_storcli_number	rozofs_rw_load_balancing.c	/^int stclbg_update_storcli_number (int nb) {$/;"	f
storage_timeout	rozofsmount.h	/^    unsigned storage_timeout;$/;"	m	struct:rozofsmnt_conf
storcli_idx	rzcp_file_ctx.h	/^   int   storcli_idx;      \/**< index of the strocli to use     *\/$/;"	m	struct:_rzcp_copy_ctx
storcli_timeout	rozofsmount.h	/^    unsigned storcli_timeout;$/;"	m	struct:rozofsmnt_conf
timeStamp	file.h	/^    uint64_t         timeStamp;$/;"	m	struct:file
timestamp	geocli_srv.h	/^   uint64_t timestamp;$/;"	m	struct:_geocli_ctx_t
timestamp	rzcp_file_ctx.h	/^   uint64_t timestamp;     \/**< current time for statistics     *\/$/;"	m	struct:_rzcp_copy_ctx
usage	rozofsmount.c	/^static void usage() {$/;"	f	file:
wr_error	file.h	/^    int wr_error;            \/**< last write error code                     *\/$/;"	m	struct:file
write_block_counter	file.h	/^    int              write_block_counter;  \/**< increment each time a write block is called *\/$/;"	m	struct:file
write_block_pending	file.h	/^    int              write_block_pending;  \/**< asserted when a write must be sent          *\/$/;"	m	struct:file
write_block_req	file.h	/^    int              write_block_req;  \/**< to force the write towards the metadata service (flush and close)          *\/$/;"	m	struct:file
write_ctx	rzcp_file_ctx.h	/^   rzcp_file_ctx_t write_ctx;  $/;"	m	struct:_rzcp_copy_ctx
write_from	file.h	/^    uint64_t write_from; \/**< absolute position of the last available byte to read *\/$/;"	m	struct:file
write_pos	file.h	/^    uint64_t write_pos;  \/**< absolute position of the first available byte to read*\/$/;"	m	struct:file
xmalloc_stats_t	rozofsmount.c	/^} xmalloc_stats_t;$/;"	t	typeref:struct:_xmalloc_stats_t	file:
